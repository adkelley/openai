/// Issues a Responses API call configured to delegate web search to an MCP server.
import envoy
import gleam/io
import gleam/json.{type Json}
import gleam/list
import gleam/option.{Some}

import openai/error.{type OpenaiError}
import openai/responses
import openai/responses/types/request.{
  Auto, ContentInputText, FunctionCallOutput, FunctionCalling, InputList,
  InputListItemMessage, OutputFunctionCall, RoleContent,
}
import openai/responses/types/response.{type Response}
import openai/types as shared

/// Requires `OPENAI_API_KEY` to be set in the environment.
pub fn main() -> Result(Response, OpenaiError) {
  let assert Ok(api_key) = envoy.get("OPENAI_API_KEY")

  // 1. Define list of callable tools for the model
  let parameters_encoder = fn() -> Json {
    json.object([
      #("type", json.string("object")),
      #(
        "properties",
        json.object([
          #(
            "sign",
            json.object([
              #("type", json.string("string")),
              #(
                "description",
                json.string("An astrological sign like Taurus or Aquarius"),
              ),
            ]),
          ),
        ]),
      ),
      #("required", json.array(["sign"], of: json.string)),
      #("additionalProperties", json.bool(False)),
    ])
  }

  let horoscope_tool =
    FunctionCalling(
      name: "get_horoscope",
      description: "Get today's horoscope for an astrological sign",
      parameters: parameters_encoder(),
      strict: True,
    )

  let get_horoscope = fn(_arguments: String) -> String {
    json.object([
      #("sign", json.string("Cancer")),
      #(
        "horoscope",
        json.string("Next Tuesday you wuii befriend a  baby otter"),
      ),
    ])
    |> json.to_string()
  }

  // Create a running input list we will add over time
  let content_input_text = "What is my horoscope?  I am a Cancer"
  let hop1 =
    InputList([
      InputListItemMessage(RoleContent(
        role: "user",
        content: ContentInputText(content_input_text),
      )),
    ])
  io.println("\nPrompt: " <> content_input_text)

  let config =
    responses.default_request()
    |> responses.model(shared.GPT5)
    |> responses.input(hop1)
    |> responses.function_tool_choice(Auto)
    // Define the list of callable tools for the model
    |> responses.tools(Some([]), horoscope_tool)

  // 2. Prompt the model with tools defined
  let assert Ok(response) = responses.create(api_key, config)
  // echo response.output

  let InputList(hop1) = hop1
  let hop2 =
    list.fold(response.output, hop1, fn(acc, item) {
      case item {
        response.OutputReasoning(id:, summary:, content:) -> {
          let summary_ =
            list.fold(summary, [], fn(acc, item) {
              let response.OutputReasoningSummary(item_) = item
              list.prepend(acc, request.OutputReasoningSummary(item_))
            })
          let content_ =
            list.fold(content, [], fn(acc, item) {
              let response.OutputReasoningContent(item_) = item
              list.prepend(acc, request.OutputReasoningContent(item_))
            })
          list.append(acc, [
            InputListItemMessage(request.OutputReasoning(
              id:,
              summary: summary_,
              content: content_,
            )),
          ])
        }
        response.OutputFunctionCall(status:, id:, call_id:, name:, arguments:) -> {
          let acc_ =
            list.append(acc, [
              InputListItemMessage(OutputFunctionCall(
                status,
                id,
                call_id,
                name,
                arguments,
              )),
            ])
          case name {
            "get_horoscope" -> {
              let horoscope = get_horoscope(arguments)
              list.append(acc_, [
                InputListItemMessage(FunctionCallOutput(
                  call_id:,
                  output: json.string(horoscope),
                )),
              ])
            }
            _ -> panic as "unrecognized function call"
          }
        }
        _ -> acc
      }
    })

  let config =
    responses.default_request()
    |> responses.model(shared.GPT5)
    |> responses.instructions(Some(
      "Respond only with a horoscope generated by a tool.",
    ))
    |> responses.input(InputList(hop2))
    // Define the list of callable tools for the model
    |> responses.tools(Some([]), horoscope_tool)

  let assert Ok(response) = responses.create(api_key, config)
  echo response.output
  Ok(response)
}
